#!/bin/bash

# show help
__help() {
  echo
  echo "ruby package installer - using rvm binaries"
  echo
  echo "Script will try to detect OS, Version and Machinetype to locate fitting ruby package."
  echo "You can override by passing ruby release id and optinial os-version."
  echo
  echo "ruby-install                          install latest release or defined by ruby-release file"
  echo "ruby-install 2.0.0                    install different release"
  echo "ruby-install jessie_sid 1.9.3-p453    install different os release and ruby release"
  echo "ruby-install local                    install just symbolic links to already OS installed binaries"
  echo
  echo "Update rubygems during installation."
  echo
  echo "ruby-install --update-rubygems        install ruby and update rubygems to latest release (default)"
  echo "ruby-install --update-rubygems 2.6.1  install ruby and update rubygems to release 2.6.1"
  echo "ruby-install --no-update-rubygems     install ruby and do not update rubygems"
  echo
  echo "A list of binary you will find at:"
  echo "https://rvm.io/binaries/OS/VERSION/MACHINETYPE/ruby-RUBY-RELEASE.tar.bz2"
  echo
  exit 0
}

# change to base installation directory
BASE_PATH=$(dirname "$0")"/.."
cd "$BASE_PATH"

# source conf file to get predefined ruby release to install
source "ruby-release"

# check for existing ruby installation
if [[ -d "vendor/ruby" ]]
then
  echo
  echo "It seems that there is already a ruby installation at vendor/ruby. Please clean before new installation. Abort!"
  exit 1
fi

#initialize
__OS="unknown"
__VERSION="unknown"
__MACHINE="unknown"

# auto detect os, vers, machine
__detect_OS() {
  # check $OSTYPE var, use lowercase
  OS_CHECK=$(echo "$OSTYPE" | tr '[:upper:]' '[:lower:]')
  # build test vars
  if [[ -z "${OS_CHECK##*darwin*}" ]]; then IS_OSX="true"; else IS_OSX=""; fi
  if [[ -z "${OS_CHECK##*linux-gnu*}" ]]; then IS_GNU="true"; else IS_GNU=""; fi
  # get proc type
  MACH_CHECK=$(uname -m | tr '[:upper:]' '[:lower:]')
  # test 64bit environment
  if [[ -z "${MACH_CHECK##*_64*}" || -z "${MACH_CHECK##*amd64*}" ]]; then IS_64BIT="true"; else IS_64BIT=""; fi
  # debian based distribution
  if [[ -n "${IS_GNU}" ]]
  then
    # check for ubuntu
    if [[ -f "/etc/os-release" ]]
    then
      # extract id from file
      OS_ID=$(bash -c 'source /etc/os-release; echo "${ID}"' | tr '[:upper:]' '[:lower:]')
      # test for valid os
      if [[ "$OS_ID" == "ubuntu" ]]; then __OS=$OS_ID; fi
      # extract version from file
      __VERSION=$(bash -c 'source /etc/os-release; echo "${VERSION_ID}"')
    # check for debian
    elif [[ -f "/etc/debian_version" ]]
    then
      # fix os name
      __OS="debian"
      # try extract version name
      VERS_SID_JESSIE=$(cat /etc/debian_version | head -n 1 | egrep -i '(jessie|sid)')
      if [[ -n "${VERS_SID_JESSIE}" ]]
      then
        # set fix version id
        __VERSION="jessie_sid"
      else
        # try extract version id
        __VERSION=$(cat /etc/debian_version | head -n 1 | sed -e 's/^[^0-9]*\([0-9]\+\).*/\1/')
      fi
    fi
  fi
  # osx environment
  if [[ -n "${IS_OSX}" ]]
  then
    __OS="osx"
    __VERSION=$(sw_vers -productVersion | sed -e 's/^\([0-9]*\.[0-9]*\).*/\1/')
  fi
  # define machine type
  if [[ -n "${IS_64BIT}" ]]
  then
    __MACHINE="x86_64"
  else
    __MACHINE="i386"
  fi
}

# get system params
__detect_OS

# initialize
RUBY_RELEASE=""
UPDATE_RUBYGEMS="latest"

# read and detect args
while [ "$1" != "" ]
do
  # check arguments
  case "$1" in

    # run installer
    -h|--help)
      __help
      ;;

    # disable update of rubygems
    --no-update-rubygems)
      UPDATE_RUBYGEMS=""
      ;;

    # enable (default) update of rubygems
    --update-rubygems)
      UPDATE_RUBYGEMS="latest"
      # check for a special given release
      if [[ "$2" != "" ]]
      then
        UPDATE_RUBYGEMS="$2"
        shift
      fi
      ;;

    # test unknown options
    -*|--*)
      __help
      ;;

    # use args as options for different ruby OS VERSION and RELEASE build
    *)
      # check if special ruby release was already set
      if [[ "$RUBY_RELEASE" != "" ]]
      then
        # if more than 1 arg was given, that means version was set in front of ruby release
        __VERSION="$RUBY_RELEASE"
      fi

      # fix release to install
      RUBY_RELEASE="$1"
      ;;

  esac

  # next arg
  shift
done

# check to auto-detect latest ruby release
if [[ "${RUBY_RELEASE}" == "" || "${RUBY_RELEASE}" == "latest" ]]
then
  # try to detect latest binaries for this OS/VERSION/MACHINE
  LATEST_RUBY_RELEASE=$(curl -slL --compressed --url "https://rvm.io/binaries/${__OS}/${__VERSION}/${__MACHINE}/" | sed -e 's/^.*href="ruby-\([^"]*\)">.*/\1/' | egrep '^.*\.tar\.bz2' | sort --unique --reverse | head -n 1)
  # re-set RUBY_RELEASE
  RUBY_RELEASE="${LATEST_RUBY_RELEASE/.tar.bz2*/}"
fi

# check if to use system wide ruby installation or get binaries from rvmio
if [[ "${RUBY_RELEASE}" == "local" ]]
then
  # Installation message
  echo "Use current ruby installation from $__OS/$__MACHINE distribution release $__VERSION."

  # create symbolic links to vendor/ruby
  mkdir -p vendor/ruby/bin
  # try to locate necessary commands
  for CMD in ruby gem rake irb erb ri rdoc
  do
    [[ -x "$(which ${CMD})" ]] && ln -s "$(which ${CMD})" "vendor/ruby/bin/${CMD}"
  done

else
  # define URL
  RUBY_PACKAGE="https://rvm.io/binaries/${__OS}/${__VERSION}/${__MACHINE}/ruby-${RUBY_RELEASE}.tar.bz2"

  # Installation message
  echo "Get ruby package for os/machine type $__OS/$__MACHINE distribution release $__VERSION."
  echo "Load ruby binaries from: $RUBY_PACKAGE"

  # try to get file
  CHK_URL=$(curl -sSL -Is "$RUBY_PACKAGE" | grep -E "(HTTP/2 200|200 OK)")

  # test existing of url
  if [[ "$?" != "0" ]]
  then
    echo
    echo "Download package is not available. Abort!"
    exit 2
  fi

  # create vendor/ruby and download and extract package
  mkdir -p vendor/ruby
  RUBY_INST=$(curl -sSL "$RUBY_PACKAGE" | tar -xj -C vendor/ruby --strip-components=1 --exclude='*/config' --exclude='*/.irbrc' --exclude='*/lib/ruby/gems' --exclude='*/lib/ruby/site_ruby' --exclude='*/lib/ruby/vendor_ruby' --exclude='*/lib/pkgconfig' --exclude='*/share')

  # check status
  if [[ "$?" != "0" ]]
  then
    echo
    echo "I am sorry, there was an error during ruby installation. Please retry. Abort!"
    exit 9
  fi
fi

# update rubygems to latest available
if [[ "$UPDATE_RUBYGEMS" != "" ]]
then
  # check to detect latest rubygems release
  if [[ "$UPDATE_RUBYGEMS" == "latest" ]]
  then
    LATEST_RUBYGEMS_RELEASE=$(curl -slL --compressed --url "https://rubygems.org/pages/download?locale=en" | sed -e 's/^.*href=".*\/rubygems\/rubygems-\([^"]*\)">.*/\1/' | egrep '^.*\.tgz' | sort --unique --reverse | head -n 1)
    # re-set UPDATE_RUBYGEMS
    UPDATE_RUBYGEMS="${LATEST_RUBYGEMS_RELEASE/.tgz*/}"
  fi

  # test if able to handle that rubygems version
  if ! [[ "$UPDATE_RUBYGEMS" =~ ^([2-9]|[1-9][0-9]+)(\.[0-9]+)*$ ]]
  then
    echo
    echo "Downloaded rubygems release $UPDATE_RUBYGEMS is not supported by rvm-mini installer."
    echo "Release for rubygems update must be a valid version string starting at 2.0.0. Abort!"
    exit 2
  fi

  # define download URL
  RUBYGEMS_PACKAGE="https://rubygems.org/rubygems/rubygems-${UPDATE_RUBYGEMS}.tgz"

  # Installation message
  echo "Update rubygems package from: $RUBYGEMS_PACKAGE"

  # try to get file
  CHK_URL=$(curl -sSL -Is "$RUBYGEMS_PACKAGE" | grep -E "(HTTP/2 200|200 OK)")

  # test existing of url
  if [[ "$?" != "0" ]]
  then
    echo
    echo "Download for rubygems is not available. Abort!"
    exit 2
  fi

  # check location of current rvm built-in rubygems
  CHK_RUBYGEMS_INSTALLED=$(find vendor/ruby -type d -name 'rubygems' | wc -l | sed -e 's/[ \t\r\n]*//')

  # test existing rubygems
  if [[ "$CHK_RUBYGEMS_INSTALLED" != "1" ]]
  then
    echo
    echo "Can't handle and update your current built-in rubygems. Abort!"
    exit 2
  fi

  # get location of current rvm built-in rubygems
  CHK_RUBYGEMS_INSTALLED=$(find vendor/ruby -type d -name 'rubygems')

  # drop that installation folder // other files get overriden
  rm -rf "$CHK_RUBYGEMS_INSTALLED"

  # extract dirname to extract in
  PATH_RUBYGEMS_INSTALLED=$(dirname "$CHK_RUBYGEMS_INSTALLED")

  # in case that tar option --include is not portable we need to extract the content into
  # some temp directory and move wanted content from there
  RUBYGEMS_TMP="vendor/tmp_rubygems"

  # clean and recreate
  rm -rf "$RUBYGEMS_TMP"; mkdir -p "$RUBYGEMS_TMP"

  # download and extract package to temp path
  RUBYGEMS_INST=$(curl -sSL "$RUBYGEMS_PACKAGE" | tar -xz -C "$RUBYGEMS_TMP")

  # check status
  if [[ "$?" != "0" ]]
  then
    # in any case drop the temp folder
    rm -rf "$RUBYGEMS_TMP"

    echo
    echo "I am sorry, there was an error during rubygems installation. Please retry. Abort!"
    exit 9
  fi

  # get content from lib and replace inside old lib path
  find "$RUBYGEMS_TMP" -mindepth 3 -maxdepth 3 -path "*-$UPDATE_RUBYGEMS/lib/*" -exec mv -f "{}" "$PATH_RUBYGEMS_INSTALLED" \;

  # in any case drop the temp folder
  rm -rf "$RUBYGEMS_TMP"
fi

# get bundler to finish environment

# check project structure
mkdir -p "vendor/bundler"

# check if need to install bundler first of all
echo -e "Check bundler ... \c"
BUNDLER_VERSION="$(bin/bundle --version)"
if [[ "$?" != "0" ]]
then
  # info about new installing
  echo "Now installing ..."
  # gem install bundler
  bin/gem install bundler --no-rdoc --no-ri --install-dir vendor/bundler
  # check status
  if [[ "$?" != "0" ]]
  then
    echo
    echo "I am sorry, there was an error during bundler installation. Please retry. Abort!"
    exit 8
  fi
else
  # info already installed
  echo "installed"
fi

# well seems to ready with ruby
echo "Installation was successfull."
echo -e "ruby --version: \c" ; bin/ruby --version
echo -e "gem --version: \c" ; bin/gem --version
echo -e "bundler --version: \c" ; bin/bundle --version

exit 0;
